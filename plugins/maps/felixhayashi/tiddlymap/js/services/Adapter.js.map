{"version":3,"sources":["felixhayashi/tiddlymap/js/services/Adapter.js"],"names":["Object","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","_ViewAbstraction","require","_ViewAbstraction2","_interopRequireDefault","_EdgeType","_EdgeType2","_NodeType","_NodeType2","_utils","_utils2","_Edge","_Edge2","_vis","_vis2","_environment","env","_interopRequireWildcard","_contrastcolour","__esModule","newObj","hasOwnProperty","call","default","_defineProperty","_classCallCheck","instance","TypeError","Adapter","tracker","edgeTypeSubscriberRegistry","this","getTiddlerById","bind","getId","getIdByTiddler","assignId","indeces","$tm","wiki","$tw","visShapesWithTextInside","utils","getLookupTable","deleteEdge","edge","_processEdge","insertEdge","deleteEdges","edges","convert","action","logger","fromTRef","from","tiddlerExists","tObj","getTiddler","type","allETy","EdgeType","getInstance","handlers","getAllForType","fn","exists","save","getAdjacencyList","groupBy","opts","arguments","undefined","start","tRefs","getMatches","selector","allPotentialNodes","getEdgesForSet","toWL","typeWL","adjList","groupByProperty","stop","getNeighbours","matches","_this","addProperties","steps","visited","getArrayValuesAsHashmapKeys","view","ViewAbstraction","allEdgesLeadingToNeighbours","makeHashMap","allNeighbours","maxSteps","parseInt","direction","getConfig","isWalkBoth","isWalkIn","isWalkOut","neighFilter","getNodeFilter","addAsNeighbour","role","neighboursOfThisStep","id","tRef","isTrue","config","sys","nodeFilterNeighbours","isMatch","node","makeNode","push","step","isSystemOrDraft","outgoing","getEdges","t","toArrow","invertedArrow","incoming","j","neighbourhood","nodes","getGraph","_ref","includeNeighboursOf","neighScope","getEdgeTypeFilter","nodeIdWL","isEnabled","Set","values","forEach","add","to","graph","selectNodesByReferences","outputType","neighboutMatches","filter","neighbours","assign","nodeTRefs","getTiddlersByIds","nodesFilteredByEdges","has","attachStylesToNodes","tiddler","eTySubscribers","getAll","l","loadEdges","addStyleToEdge","tiddlers","selectEdgesByType","getAllPotentialNodes","_processEdgesWithType","_ref2","newName","deleteTiddler","fullPath","_ref3","result","keys","selectNodesByIds","nodeIds","options","selectNodeById","removeNodeType","NodeType","protoNode","merge","fields","title","label","field","nodeLabel","renderText","replace","getInheritedNodeStyles","src","protoByTRef","glNTy","inheritors","getInheritors","proto","style","inheritedStyles","viewNodeData","getNodeData","isStaticMode","icon","inheritedStyle","getIcon","color","parseJSON","nodeData","fixed","x","y","isColorObject","background","border","addNodeIcon","font","shape","run","glNTyById","deleteNode","deleteTiddlers","viewRefs","allViews","removeNode","deleteNodes","ids","insertNode","protoTiddler","generateNewTitle","getRandomLabel","Tiddler","text","tmap.id","getModificationFields","getCreationFields","addTiddler","addNode","Array","isArray","vis","DataSet","getFAdigits","str","substr","fa","face","code","String","fromCharCode","size","tw","imgTObj","image","getDataUri","removeObsoleteViewData","data","obsoleteDataItems","getLabel","saveNodeData","faIcon","twIcon"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/services/Adapter.js","sourcesContent":["/* @preserve TW-Guard */\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Adapter\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n/* @preserve TW-Guard */\n\n/*** Imports *******************************************************/\n\nimport ViewAbstraction              from '$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction';\nimport EdgeType                     from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport NodeType                     from '$:/plugins/felixhayashi/tiddlymap/js/NodeType';\nimport utils                        from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport Edge                         from '$:/plugins/felixhayashi/tiddlymap/js/Edge';\nimport vis                          from '$:/plugins/felixhayashi/vis/vis.js';\nimport * as env                     from '$:/plugins/felixhayashi/tiddlymap/js/lib/environment';\nimport { run as getContrastColour } from '$:/core/modules/macros/contrastcolour.js';\n\n/***************************** CODE ********************************/\n\n/**\n * This library acts as an abstraction layer above the tiddlywiki\n * system. All the provided methods give the api-user the chance\n * to interact with tiddlywiki as if it was a simple graph database.\n *\n * Everything that is related to retrieving or inserting nodes and\n * edges is handled by the adapter class.\n *\n * You don't need to create your own instance of this class.\n * The adapter service may be accessed from anywhere using\n * `$tm.apapter`.\n *\n * @constructor\n */\nclass Adapter {\n\n  /**\n   * @param {Tracker} tracker\n   * @param {EdgeTypeSubscriberRegistry} edgeTypeSubscriberRegistry\n   */\n  constructor(tracker, edgeTypeSubscriberRegistry) {\n\n    this.getTiddlerById = tracker.getTiddlerById.bind(tracker);\n    this.getId = tracker.getIdByTiddler.bind(tracker);\n    this.assignId = tracker.assignId.bind(tracker);\n\n    this.edgeTypeSubscriberRegistry = edgeTypeSubscriberRegistry;\n\n    this.indeces = $tm.indeces;\n    this.wiki = $tw.wiki;\n\n    this.visShapesWithTextInside = utils.getLookupTable([\n      'ellipse', 'circle', 'database', 'box', 'text'\n    ]);\n\n  }\n\n  /**\n   * This function will delete the specified edge object from the system.\n   *\n   * @param {Edge} edge - The edge to be deleted. The edge necessarily\n   *     needs to possess an `id` and a `from` property.\n   * @return {Edge} The deleted edge is returned.\n   */\n  deleteEdge(edge) {\n\n    return this._processEdge(edge, 'delete');\n\n  }\n\n  /**\n   * Persists an edge by storing the vector (from, to, type).\n   *\n   * @param {Edge} edge - The edge to be saved. The edge necessarily\n   *     needs to possess a `to` and a `from` property.\n   * @return {Edge} The newly inserted edge.\n   */\n  insertEdge(edge) {\n\n    return this._processEdge(edge, 'insert');\n\n  }\n\n  /**\n   * Removes multiple edges from several stores.\n   *\n   * @param {EdgeCollection} edges - The edges to be deleted.\n   */\n  deleteEdges(edges) {\n\n    edges = utils.convert(edges, 'array');\n    for (let i = edges.length; i--;) {\n      this.deleteEdge(edges[i]);\n    }\n\n  }\n\n  /**\n   * Private function to handle the insertion or deletion of an edge.\n   * It prepares the process according to the action type and delegates\n   * the task to more specific functions.\n   *\n   * @private\n   * @return {Edge} The processed edge.\n   */\n  _processEdge(edge, action) {\n\n    $tm.logger('debug', 'Edge', action, edge);\n\n    // get from-node and corresponding tiddler\n    const fromTRef = this.getTiddlerById(edge.from);\n\n    if (!fromTRef || !utils.tiddlerExists(fromTRef)) {\n      return;\n    }\n\n    const tObj = utils.getTiddler(fromTRef);\n    const type = this.indeces.allETy[edge.type] || EdgeType.getInstance(edge.type);\n    const handlers = this.edgeTypeSubscriberRegistry.getAllForType(type);\n    const fn = `${action}Edge`;\n\n    for (let i = handlers.length; i--;) {\n      (handlers[i][fn])(tObj, edge, type);\n    }\n\n    // if type didn't exist yet, create it\n    if (action === 'insert' && !type.exists()) {\n      type.save();\n    }\n\n    return edge;\n\n  }\n\n  /**\n   * This function will return an adjacency list for the nodes\n   * present in the current system. The list may be restricted by\n   * optional filters.\n   *\n   * @param {string} [groupBy='to'] - Specifies by which property the\n   *     adjacency list is indexed. May be either 'from' or 'to'.\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edge-types are included.\n   * @param {Hashmap} [opts.edges] - A set of edges on which basis\n   *     the adjacency list is build. If not provided,\n   *     all edges in the system are considered.\n   * @return {Object<Id, Array<Edge>>} For each key (a node id) an\n   *     array of edges pointing 'from' (or 'to'; depends on `groupBy`)\n   *     is supplied as value.\n   */\n  getAdjacencyList(groupBy, opts = {}) {\n\n    $tm.start('Creating adjacency list');\n\n    if (!opts.edges) {\n      const tRefs = utils.getMatches(env.selector.allPotentialNodes);\n      opts.edges = this.getEdgesForSet(tRefs, opts.toWL, opts.typeWL);\n    }\n\n    const adjList = utils.groupByProperty(opts.edges, groupBy || 'to');\n\n    $tm.stop('Creating adjacency list');\n\n    return adjList;\n\n  }\n\n  /**\n   * This function will return all neighbours of a graph denoted by\n   * a set of tiddlers.\n   *\n   * @todo parts of this code may be outsourced into a function to\n   * prevent repeating code.\n   *\n   * @param {Array<TiddlerReference>} matches - The original set that\n   *     defines the starting point for the neighbourhood discovery\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edges are travelled to reach a neighbour.\n   * @param {Hashmap} [opts.edges] - An initial set of edges that is\n   *    used in the first step to reach immediate neighbours, if no\n   *    set of edges is specified, all exsisting edges will be considered.\n   * @param {number} [opts.steps] - An integer value that specifies\n   *    the scope of the neighbourhood. A node is considered a neighbour\n   *    if it can be reached within the given number of steps starting\n   *    from original set of tiddlers returned by the node filter.\n   * @param {Hashmap} [opts.addProperties] - a hashmap\n   *     containing properties to be added to each node.\n   *     For example:\n   *     {\n   *       group: 'g1',\n   *       color: 'red'\n   *     }\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all neighbouring nodes* },\n   *       edges: { *all edges connected to neighbours* },\n   *     }\n   */\n  getNeighbours(matches, opts = {}) {\n\n    $tm.start('Get neighbours');\n\n    const { addProperties, toWL, typeWL, steps } = opts;\n    const { allETy } = this.indeces;\n\n    // index of all tiddlers have already are been visited, either by\n    // having been included in the original set, or by having been\n    // recorded as neighbour during the discovery.\n    const visited = utils.getArrayValuesAsHashmapKeys(matches);\n    const view = ViewAbstraction.exists(opts.view) ? new ViewAbstraction(opts.view) : null;\n    const allEdgesLeadingToNeighbours = utils.makeHashMap();\n    const allNeighbours = utils.makeHashMap();\n    const maxSteps = (parseInt(steps) > 0 ? steps : 1);\n    const direction = (opts.direction || (view && view.getConfig('neighbourhood_directions')));\n    const isWalkBoth = (!direction || direction === 'both');\n    const isWalkIn = (isWalkBoth || direction === 'in');\n    const isWalkOut = (isWalkBoth || direction === 'out');\n\n    // in order to apply the node-filter also to neighbours we need to make it\n    // include all tiddlers in the filter's source (e.g. a tiddler and a few neighbours)\n    // and then apply the filter – which now has the chance to take away tiddlers\n    // a few filters from the set\n    const neighFilter = view && `[all[]] ${view.getNodeFilter('raw')}`;\n\n    // adjacency receives whitelists through opts\n    const adjList = this.getAdjacencyList('to', opts);\n\n    const addAsNeighbour = (edge, role, neighboursOfThisStep) => {\n      allEdgesLeadingToNeighbours[edge.id] = edge;\n      const tRef = this.getTiddlerById(edge[role]);\n\n      if (\n        view\n        && utils.isTrue($tm.config.sys.nodeFilterNeighbours)\n        && !utils.isMatch(tRef, neighFilter)) {\n        return;\n      }\n\n      if (!visited[tRef]) {\n        visited[tRef] = true;\n        const node = this.makeNode(tRef, addProperties);\n        if (node) { // saveguard against obsolete edges or other problems\n          // record node\n          allNeighbours[node.id] = node;\n          neighboursOfThisStep.push(tRef);\n        }\n      }\n    };\n\n    // needed later\n    let step;\n\n    // loop if still steps to be taken and we have a non-empty starting set\n    for (step = 0; step < maxSteps && matches.length; step++) {\n\n      // neighbours that are discovered in the current step;\n      // starting off from the current set of matches;\n      const neighboursOfThisStep = [];\n\n      // loop over all nodes in the original set\n      for (let i = matches.length; i--;) {\n\n        if (utils.isSystemOrDraft(matches[i])) {\n          // = this might happen if the user manually created edges\n          // that link to a system/draft tiddler or if the original\n          // set contained system/draft tiddlers.\n          continue;\n        }\n\n        // get all outgoing edges\n        // = edges originating from the starting set and point outwards\n        const outgoing = this.getEdges(matches[i], toWL, typeWL);\n        for (let id in outgoing) {\n\n          const t = allETy[outgoing[id].type];\n          if (isWalkBoth || isWalkOut && t.toArrow || isWalkIn && t.invertedArrow) {\n\n            addAsNeighbour(outgoing[id], 'to', neighboursOfThisStep);\n          }\n        }\n\n        // get all incoming edges\n        // = edges originating from outside pointing to the starting set\n        const incoming = adjList[this.getId(matches[i])];\n        if (!incoming) {\n          continue;\n        }\n\n        for (let j = incoming.length; j--;) {\n          const t = allETy[incoming[j].type];\n          if (isWalkBoth || isWalkIn && t.toArrow || isWalkOut && t.invertedArrow) {\n            addAsNeighbour(incoming[j], 'from', neighboursOfThisStep);\n          }\n        }\n      }\n\n      // the current set of newly discovered neighbours forms the\n      // starting point for the next discovery\n      matches = neighboursOfThisStep;\n\n    }\n\n    const neighbourhood = {\n      nodes: allNeighbours,\n      edges: allEdgesLeadingToNeighbours\n    };\n\n    $tm.logger('debug', 'Retrieved neighbourhood', neighbourhood, 'steps', step);\n\n    $tm.stop('Get neighbours');\n\n    return neighbourhood;\n\n  }\n\n  /**\n   * This function will assemble a graph object based on the supplied\n   * node and edge filters. Optionally, a neighbourhood may be\n   * merged into the graph neighbourhood.\n   *\n   * @param {string|ViewAbstraction} [view] - The view in which\n   *     the graph will be displayed.\n   *     See {@link Adapter#getNeighbours}\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all nodes in the graph* },\n   *       edges: { *all edges in the graph* },\n   *     }\n   *     Neighbours will be receive the 'tmap:neighbour' type.\n   */\n  getGraph({ view, matches, includeNeighboursOf }) {\n\n    $tm.start('Assembling Graph');\n\n    view =  new ViewAbstraction(view);\n    matches = matches || utils.getMatches(view.getNodeFilter('compiled'));\n    const neighScope = parseInt(view.getConfig('neighbourhood_scope'));\n    const typeWL = view.getEdgeTypeFilter('whitelist');\n    const toWL = utils.getArrayValuesAsHashmapKeys(matches);\n    const edges = this.getEdgesForSet(matches, toWL, typeWL);\n\n    let nodeIdWL;\n    if (view.isEnabled('filter_nodes_by_edge_types')) {\n      nodeIdWL = new Set();\n      Object.values(edges)\n        .forEach(edge => { nodeIdWL.add(edge.from); nodeIdWL.add(edge.to); });\n    }\n\n    const graph = {\n      edges,\n      nodes: this.selectNodesByReferences(matches, {\n        view: view,\n        outputType: 'hashmap'\n      })\n    };\n\n    if (neighScope) {\n      const neighboutMatches = includeNeighboursOf\n        ? matches.filter(includeNeighboursOf)\n        : matches;\n      const neighbours = this.getNeighbours(neighboutMatches, {\n        steps: neighScope,\n        view: view,\n        typeWL: typeWL,\n        addProperties: {\n          type: 'tmap:neighbour'\n        }\n      });\n\n      // add neighbours (nodes and edges) to graph\n      Object.assign(graph.nodes, neighbours.nodes);\n      Object.assign(graph.edges, neighbours.edges);\n\n      if (view && view.isEnabled('show_inter_neighbour_edges')) {\n        const nodeTRefs = this.getTiddlersByIds(neighbours.nodes);\n        // this time we need a whitelist based on the nodeTRefs\n        const toWL = utils.getArrayValuesAsHashmapKeys(nodeTRefs);\n        Object.assign(graph.edges, this.getEdgesForSet(nodeTRefs, toWL));\n      }\n    }\n\n    if (nodeIdWL) {\n      const nodesFilteredByEdges = utils.makeHashMap();\n      Object.values(graph.nodes)\n        .forEach(node => { if (nodeIdWL.has(node.id)) { nodesFilteredByEdges[node.id] = node; } })\n      graph.nodes = nodesFilteredByEdges;\n    }\n\n    // this is pure maintainance!\n    // removeObsoleteViewData(graph.nodes, view);\n\n    // add styles to nodes\n    this.attachStylesToNodes(graph.nodes, view);\n\n    $tm.stop('Assembling Graph');\n\n    $tm.logger('debug', 'Assembled graph:', graph);\n\n    return graph;\n\n  }\n\n  /**\n   * Returns all edges stored in a given tiddler. Any edge stored in a\n   * tiddler is orginally an outgoing edge. Depending on how the user\n   * changes the arrow head (by manipulating the Visjs edge-type style),\n   * the edge may change its orientation and become an incoming edge or\n   * bi-directional. Therefore, the edges retrieved may be incoming,\n   * outgoing or both!\n   *\n   * Returned edges may be of the following type:\n   *\n   * - Edges stored in the tiddler text (=links).\n   * - Edges stored in fields denoted by magic edge-types.\n   * - TiddlyMap edges stored in a json format\n   *\n   * @param {Tiddler} tiddler - A tiddler reference or object from\n   *     which to retrieve the edges.\n   * @param {Hashmap<TiddlerReference, boolean>} [toWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge that leads to a certain tiddler in the result or not.\n   *     In this case, all edges stored in the tiddler are treated as\n   *     outgoing and the arrow head is ignored. If not specified,\n   *     all edges are included.\n   * @param {Hashmap<string, boolean>} [typeWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge of a given type in the result or not. If not\n   *     specified, all edges are included.\n   */\n  getEdges(tiddler, toWL, typeWL) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) {\n      return;\n    }\n\n    const { allETy } = this.indeces;\n    const edges = utils.makeHashMap();\n    const eTySubscribers = this.edgeTypeSubscriberRegistry.getAll();\n\n    for (let i = 0, l = eTySubscribers.length; i < l; i++) {\n      Object.assign(edges, (eTySubscribers[i]).loadEdges(tObj, toWL, typeWL));\n    }\n\n    for (let id in edges) {\n\n      const edge = edges[id];\n\n      // check exists for historical reasons...\n      if (!edge.from || !edge.to) {\n        continue;\n      }\n\n      const type = allETy[edge.type] || EdgeType.getInstance(edge.type);\n      addStyleToEdge(edges[id], type);\n\n      edges[id] = edge;\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * The method will return all outgoing edges for a subset of tiddlers.\n   *\n   * @param {Array<Tiddler>} tiddlers - The set of tiddlers to consider.\n   * @param toWL\n   * @param typeWL\n   * @return {Hashmap<Id, Edge>} An edge collection.\n   */\n  getEdgesForSet(tiddlers, toWL, typeWL) {\n\n    const edges = utils.makeHashMap();\n    for (let i = tiddlers.length; i--;) {\n      Object.assign(edges, this.getEdges(tiddlers[i], toWL, typeWL));\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * Select all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   */\n  selectEdgesByType(type) {\n\n    const typeWL = utils.makeHashMap({\n      [EdgeType.getInstance(type).id]: true,\n    });\n\n    return this.getEdgesForSet(this.getAllPotentialNodes(), null, typeWL);\n\n  }\n\n  /**\n   *\n   * @return {*}\n   */\n  getAllPotentialNodes() {\n\n    return utils.getMatches($tm.selector.allPotentialNodes);\n\n  };\n\n  /**\n   * Deletes or renames all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   * @param {('rename'|'delete')} [action='delete']\n   * @param {string} [newName]\n   */\n  _processEdgesWithType(type, { action, newName }) {\n\n    type = EdgeType.getInstance(type);\n\n    $tm.logger('debug', 'Processing edges', type, action);\n\n    // get edges\n    const edges = this.selectEdgesByType(type);\n\n    if (action === 'rename') {\n\n      // clone type first to prevent auto-creation\n      (new EdgeType(newName, type)).save();\n\n    }\n\n    for (let id in edges) {\n\n      this._processEdge(edges[id], 'delete');\n\n      if (action === 'rename') {\n        edges[id].type = newName;\n        this._processEdge(edges[id], 'insert');\n      }\n    }\n\n    // finally remove the old type\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Returns a set of nodes that corresponds to a set of tiddlers.\n   *\n   * @param {TiddlerCollection} tiddlers - A collection of tiddlers.\n   * @param {Hashmap} [addProperties] - a hashmap\n   * @param {CollectionTypeString} [outputType='dataset'] - The result type.\n   *\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByReferences(tiddlers, { addProperties, outputType } = {}) {\n\n    const result = utils.makeHashMap();\n    const keys = Object.keys(tiddlers);\n\n    for (let i = keys.length; i--;) {\n\n      const node = this.makeNode(tiddlers[keys[i]], addProperties);\n      if (node) {\n        result[node.id] = node;\n      }\n\n    }\n\n    return utils.convert(result, outputType);\n\n  }\n\n  /**\n   * Retrieve nodes based on the a list of ids that corrspond to tiddlers\n   * id fields.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids of the tiddlers\n   *     that represent the nodes.\n   * @param {Hashmap} [options] - See {@link Adapter#selectNodesByReferences}.\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByIds(nodeIds, options) {\n\n    const tRefs = this.getTiddlersByIds(nodeIds);\n\n    return this.selectNodesByReferences(tRefs, options);\n\n  }\n\n  /**\n   * Select a single node by id.\n   *\n   * @param {Id} id - A node's id\n   * @param {Hashmap} [options]\n   *     Except from the outputType option, all options\n   *     are inherited from {@link Adapter#selectNodesByIds}.\n   * @return {Node|undefined} A node or nothing.\n   */\n  selectNodeById(id, options) {\n\n    options = Object.assign({}, options, { outputType: 'hashmap' });\n    const result = this.selectNodesByIds([ id ], options);\n\n    return result[id];\n\n  }\n\n  /**\n   * Deletes a node type from the system.\n   * @param {NodeType|string} type - the node type id or the actual NodeType\n   */\n  removeNodeType(type) {\n\n    type = NodeType.getInstance(type);\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Gets a Node representation for a tiddler.\n   *\n   * @param {Tiddler} tiddler - the tiddler to represent as node\n   * @param {Object} protoNode - default node properties\n   *\n   * @return {Node|void}\n   */\n  makeNode(tiddler, protoNode) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) return;\n\n    // merge(!) so later node manipulations do not affect other nodes\n    const node = utils.merge({}, protoNode);\n\n    // note: assignId() will not assign an id if the tiddler already has one\n    node.id = this.assignId(tObj);\n\n    // backreference to tiddler;\n    // https://github.com/felixhayashi/TW5-TiddlyMap/issues/304\n    node.tRef = tObj.fields.title;\n\n    // add label\n    const label = tObj.fields[$tm.field.nodeLabel];\n    node.label = (\n      label && $tm.field.nodeLabel !== 'title'\n        ? this.wiki.renderText('text/plain', 'text/vnd-tiddlywiki', label)\n        : tObj.fields.title\n    ).replace('\\\\n', '\\n');\n\n    return node;\n\n  }\n\n  /**\n   * Return node styles that are inherited from system styles or node types.\n   *\n   * @param nodes\n   * @return {Object<TiddlerReference, Object>}\n   */\n  getInheritedNodeStyles(nodes) {\n\n    const src = this.getTiddlersByIds(nodes);\n    const protoByTRef = {};\n    const glNTy = this.indeces.glNTy;\n\n    for (let i = glNTy.length; i--;) {\n      const type = glNTy[i];\n\n      let inheritors = [];\n      if (type.id === 'tmap:neighbour') { // special case\n        for (let id in nodes) {\n\n          if (nodes[id].type === 'tmap:neighbour') {\n\n            inheritors.push(this.getTiddlerById(id));\n          }\n        }\n      } else {\n        inheritors = type.getInheritors(src);\n      }\n\n      for (let j = inheritors.length; j--;) {\n        const tRef = inheritors[j];\n        const proto = protoByTRef[tRef] = (protoByTRef[tRef] || {});\n        proto.style = utils.merge(\n          proto.style || {},\n          type.style\n        );\n\n        // ATTENTION: only override proto icons when the type provides\n        // an icon since otherwise we might erase previously\n        // inherited icons.\n        if (type['fa-icon']) {\n          proto['fa-icon'] = type['fa-icon'];\n        } else if (type['tw-icon']) {\n          proto['tw-icon'] = type['tw-icon'];\n        }\n\n      }\n    }\n\n    return protoByTRef;\n\n  }\n\n  /**\n   * Adds styles to nodes.\n   *\n   * @param {Object<string, Node>} nodes\n   * @param {ViewAbstraction|string} view\n   */\n  attachStylesToNodes(nodes, view) {\n\n    view = ViewAbstraction.exists(view) ? new ViewAbstraction(view) : null;\n\n    const inheritedStyles = this.getInheritedNodeStyles(nodes);\n    const viewNodeData = view ? view.getNodeData() : utils.makeHashMap();\n    const isStaticMode = view && !view.isEnabled('physics_mode');\n\n    for (let id in nodes) {\n\n      const tRef = this.getTiddlerById(id);\n      const tObj = this.wiki.getTiddler(tRef);\n      const fields = tObj.fields;\n      const node = nodes[id];\n      let icon;\n\n      // == group styles ==\n\n      const inheritedStyle = inheritedStyles[tRef];\n\n      if (inheritedStyle) {\n\n        utils.merge(node, inheritedStyle.style);\n        icon = getIcon(inheritedStyle['fa-icon'], inheritedStyle['tw-icon']);\n      }\n\n      // == global node styles ==\n\n      // background color\n      if (fields.color) {\n        node.color = fields.color;\n      }\n\n      // global node style from vis editor\n      if (fields['tmap.style']) {\n        utils.merge(node, utils.parseJSON(fields['tmap.style']));\n      }\n\n      icon = getIcon(fields['tmap.fa-icon'], fields['icon']) || icon;\n\n      // == local node styles ==\n\n      // local node style and positions\n\n      const nodeData = viewNodeData[id];\n\n      if (nodeData) {\n\n        utils.merge(node, nodeData);\n        if (isStaticMode) {\n          // fix x if x-position is set; same for y\n          node.fixed = {\n            x: (node.x != null),\n            y: (node.y != null)\n          };\n        }\n\n        icon = getIcon(nodeData['fa-icon'], nodeData['tw-icon']) || icon;\n      }\n\n      // == tweaks ==\n\n      const isColorObject = (node.color !== null && typeof node.color === 'object');\n      // color/border-color may be undefined\n      const color = (isColorObject ? node.color.background : node.color);\n\n      node.color = {\n        background: color,\n        border: (isColorObject ? node.color.border : undefined)\n      };\n\n      // ATTENTION: this function needs to be called after color is assigned\n      addNodeIcon(node, icon);\n\n      // determine font color if not defined via a group- or node-style;\n      // in case of global and local default styles, the user is responsible\n      // him- or herself to adjust the font\n      node.font = node.font || {};\n\n      if (node.shape && !this.visShapesWithTextInside[node.shape]) {\n        node.font.color = 'black'; // force a black color\n      } else if (!node.font.color && color) {\n        node.font.color = getContrastColour(color, color, 'black', 'white');\n      }\n\n      if (node.shape === 'icon') {\n        // prefixing with a newline symbol as a hack to keep\n        // visjs' \"widthConstraint\" working for icons and to prevent\n        // text being too close to fontawesome icons\n        node.label = '\\n' + node.label;\n\n        if (typeof node.icon === 'object') {\n          node.icon.color = color;\n        }\n      }\n\n    }\n\n    if (view) {\n      const node = nodes[view.getConfig('central-topic')];\n      if (node) {\n        utils.merge(node, this.indeces.glNTyById['tmap:central-topic'].style);\n      }\n    }\n\n  }\n\n  /**\n   * This function will remove all tiddlers from the wiki that correspond\n   * to a node in the collection. Drafts are also removed. The default\n   * storylist is updated eventually.\n   * call deleteNode which does the following\n   * 1. get id using IdByT\n   * 2. remove id using adapter.deleteEdgesByTo(idByT[tRef])\n   * 3. remove from all indeces\n   *\n   * @see: https://github.com/Jermolene/TiddlyWiki5/issues/1550\n   *\n   * @param {Node|string} node.\n   */\n  deleteNode(node) {\n\n    if (!node) {\n      return;\n    }\n\n    const id = (typeof node === 'object' ? node.id : node);\n    const tRef = this.getTiddlerById(id);\n\n    // delete tiddler and remove it from the river; this will\n    // automatically remove the global node style and the outgoing edges\n\n    if (tRef) {\n      // checking for tRef is needed;\n      // see: https://github.com/Jermolene/TiddlyWiki5/issues/1919\n      utils.deleteTiddlers([ tRef ]);\n    }\n\n    // delete local node-data in views containing the node\n\n    const viewRefs = utils.getMatches(env.selector.allViews);\n    for (let i = viewRefs.length; i--;) {\n      const view = new ViewAbstraction(viewRefs[i]);\n      view.removeNode(id);\n    }\n\n    // remove obsolete connected edges\n\n    const neighbours = this.getNeighbours([ tRef ]);\n    this.deleteEdges(neighbours.edges);\n\n    // -------------------------------------------\n    // NEVER DELETE AN INDEX THAT ALREADY EXISTED!\n    // -------------------------------------------\n    // Some instances may have cached the index and get confused!\n    // It does not do harm to leave indeces as is since we do not\n    // iterate over them(!) and when a tiddler has the same title or\n    // id as a deleted tiddler, which is highly unlikely, then it will\n    // simply override the index, which is totally fine. The indeces\n    // are refreshed on every boot anyway so it is not a big deal.\n    //\n    // THEREFORE:\n    //\n    // DO NOT DO delete this.tById[id];\n    // DO NOT DO delete this.idByT[tRef];\n\n  }\n\n  /**\n   * Delete all nodes from the system.\n   *\n   * @param {string[]} ids ids\n   */\n  deleteNodes(ids) {\n\n    for (let i = ids.length; i--;) {\n      this.deleteNode(ids[i]);\n    }\n\n  }\n\n  /**\n   * Create a new tiddler that gets a non-existant title and is opened\n   * for edit. If a view is registered, the fields of the tiddler match\n   * the current view. If arguments network and position are specified,\n   * the node is also inserted directly into the graph at the given\n   * position.\n   *\n   * @TODO: Description is obsolete!\n   *\n   * @param {object} node A node object to be inserted\n   * @param {ViewAbstraction|string} view - used to set positions and register the node to\n   * @param {Tiddler} protoTiddler\n   */\n  insertNode(node = {}, view, protoTiddler) {\n\n    // title might has changed after generateNewTitle()\n    node.label = this.wiki.generateNewTitle(node.label || utils.getRandomLabel());\n\n    // add to tiddler store\n    const tObj = new $tw.Tiddler(\n      { text: '' }, // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n      protoTiddler,\n      {\n        title: node.label, // force title\n        'tmap.id': null // force empty id (generated later)\n      },\n      this.wiki.getModificationFields(),\n      this.wiki.getCreationFields()\n    );\n\n    this.wiki.addTiddler(tObj);\n\n    node = this.makeNode(tObj, node);\n\n    if (ViewAbstraction.exists(view)) {\n      (new ViewAbstraction(view)).addNode(node);\n    }\n\n    return node;\n\n  }\n\n  /**\n   * Retrieve tiddlers based on the a list of corresponding ids.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids.\n   * @return {Array<TiddlerReference>} The resulting tiddlers.\n   */\n  getTiddlersByIds(nodeIds) {\n\n    // transform into a hashmap with all values being true\n    if (Array.isArray(nodeIds)) {\n      nodeIds = utils.getArrayValuesAsHashmapKeys(nodeIds);\n    } else if (nodeIds instanceof vis.DataSet) {\n      nodeIds = utils.getLookupTable(nodeIds, 'id'); // use id field as key\n    }\n\n    const result = [];\n    for (let id in nodeIds) {\n      const tRef = this.getTiddlerById(id);\n      if (tRef) {\n        result.push(tRef);\n      }\n    }\n\n    return result;\n\n  }\n}\n\n/**** Helper *******************************************************/\n\n/**\n * Returns the short symbol identifier (`&#xf2bc;` → `f206`).\n *\n * @param str FontAwesome id\n * @return {string}\n */\nconst getFAdigits = (str) => (str.length === 4 ? str : str.substr(3, 4));\n\n/**\n * Adds an icon to the specified node.\n *\n * @param {Node} node\n * @param {Object} icon\n */\nconst addNodeIcon = (node, icon) => {\n\n  if (!icon) {\n    return;\n  }\n\n  // Font Awesome style\n\n  if (icon.fa) {\n\n    node.shape = 'icon';\n    node.icon = {\n      shape: 'icon',\n      face: 'FontAwesome',\n      color: node.color,\n      code: String.fromCharCode('0x' + getFAdigits(icon.fa)),\n    };\n\n    if (node.size) {\n      node.icon.size = node.size;\n    }\n\n    return;\n  }\n\n  // TiddlyWiki stored icons\n\n  if (icon.tw) {\n\n    const imgTObj = utils.getTiddler(icon.tw);\n\n    if (!imgTObj) {\n      return;\n    }\n\n    if (imgTObj.fields['_canonical_uri']) { // image is a url address\n\n      node.image = imgTObj.fields['_canonical_uri'];\n      node.shape = 'image';\n\n    } else if (imgTObj.fields.text) {\n\n      node.image = utils.getDataUri(imgTObj);\n      node.shape = 'image';\n    }\n  }\n\n};\n\n/**\n * Garbage collector for obsolete node data.\n *\n * @param {Object<string, Node>} nodes\n * @param {ViewAbstraction|string} view\n */\nconst removeObsoleteViewData = (nodes, view) => {\n\n  if (!ViewAbstraction.exists(view) || !nodes) {\n    return;\n  }\n\n  view = new ViewAbstraction(view);\n\n  const data = view.getNodeData();\n\n  let obsoleteDataItems = 0;\n  for (let id in data) {\n    if (nodes[id] === undefined && data[id] != null) {\n      // we only set this to undefined as deletion would\n      // slow down V8, however, this necessarily requires\n      // a safeguard agains recursion: data[id] != null\n\n      data[id] = undefined;\n      obsoleteDataItems++;\n    }\n  }\n\n  if (obsoleteDataItems) {\n    $tm.logger('debug', '[Cleanup]',\n      'Removed obsolete node data:',\n      view.getLabel(), obsoleteDataItems);\n    view.saveNodeData(data);\n  }\n\n};\n\n/**\n * Sets up an edge object that is ready to be consumed by vis.\n *\n * @param {Edge} edge\n * @param {EdgeType} type\n */\nconst addStyleToEdge = (edge, type) => {\n\n  edge = Object.assign(edge, type.style);\n\n  if (utils.isTrue(type['show-label'], true)) {\n    edge.label = type.getLabel();\n  }\n\n};\n\nconst getIcon = (faIcon, twIcon) => faIcon && { fa: faIcon } || twIcon && { tw: twIcon };\n\n/*** Exports *******************************************************/\n\nexport default Adapter;\n"],"sourceRoot":"../../../../../../src/plugins"}